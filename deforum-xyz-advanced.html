<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deforum X/Y/Z Plot Generator</title>
    <style>
        /* Previous CSS remains unchanged */
        .param-info {
            font-size: 0.9em;
            color: #999;
            margin-top: 5px;
            background-color: #2a2a2a;
            padding: 5px;
            border-radius: 4px;
        }
        .param-info strong {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <!-- Previous HTML body remains unchanged -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        let baseSettings = null;
        let parameterList = [];
        let generatedSettings = [];
        let zEnabled = false;
        let keyframePromptCounter = 0;

        // Improved range parsing function
        function parseRange(rangeStr) {
            rangeStr = rangeStr.trim();
            
            // Support for various range formats
            const parseFormats = [
                // Simple ranges like "1-5" or "0.1-1.0"
                {
                    regex: /^(\-?\d*\.?\d+)-(\-?\d*\.?\d+)$/,
                    parse: (match) => {
                        const start = parseFloat(match[1]);
                        const end = parseFloat(match[2]);
                        const isInteger = !rangeStr.includes('.');
                        const result = [];
                        
                        if (isInteger) {
                            const step = start <= end ? 1 : -1;
                            for (let i = start; (step > 0) ? i <= end : i >= end; i += step) {
                                result.push(i);
                            }
                        } else {
                            const step = start <= end ? 0.1 : -0.1;
                            for (let i = start; (step > 0) ? i <= end + 0.0001 : i >= end - 0.0001; i += step) {
                                result.push(parseFloat(i.toFixed(1)));
                            }
                        }
                        return result;
                    }
                },
                // Ranges with increment like "1-5 (+2)" or "1-3 (+0.5)"
                {
                    regex: /^(\-?\d*\.?\d+)-(\-?\d*\.?\d+)\s*\(\s*(\+|\-)(\d*\.?\d+)\s*\)$/,
                    parse: (match) => {
                        const start = parseFloat(match[1]);
                        const end = parseFloat(match[2]);
                        const sign = match[3] === '+' ? 1 : -1;
                        const increment = parseFloat(match[4]) * sign;
                        const result = [start];
                        
                        let current = start;
                        while ((increment > 0 && current + increment <= end) || 
                               (increment < 0 && current + increment >= end)) {
                            current += increment;
                            result.push(parseFloat(current.toFixed(10)));
                        }
                        
                        return result;
                    }
                },
                // Ranges with count like "1-10 [5]" or "0.0-1.0 [6]"
                {
                    regex: /^(\-?\d*\.?\d+)-(\-?\d*\.?\d+)\s*\[\s*(\d+)\s*\]$/,
                    parse: (match) => {
                        const start = parseFloat(match[1]);
                        const end = parseFloat(match[2]);
                        const count = parseInt(match[3]);
                        
                        if (count < 2) return [start];
                        
                        const result = [];
                        const step = (end - start) / (count - 1);
                        
                        for (let i = 0; i < count; i++) {
                            const value = start + i * step;
                            result.push(parseFloat(value.toFixed(10)));
                        }
                        
                        return result;
                    }
                }
            ];

            // Try each parsing format
            for (const format of parseFormats) {
                const match = rangeStr.match(format.regex);
                if (match) {
                    return format.parse(match);
                }
            }
            
            // If no specific range format, return as a single value
            return [parseParameterValue(rangeStr)];
        }

        // Improved parameter value parsing
        function parseParameterValue(value) {
            // More flexible value parsing
            value = value.trim();
            
            // Check for boolean
            if (value.toLowerCase() === 'true') return true;
            if (value.toLowerCase() === 'false') return false;
            
            // Try parsing as number
            const numValue = Number(value);
            if (!isNaN(numValue)) return numValue;
            
            // Default to string
            return value;
        }

        // Simplified type detection for display purposes
        function getParameterType(value) {
            if (value === true || value === false) return 'boolean';
            if (typeof value === 'number') return 'number';
            if (typeof value === 'string') {
                // Check for schedule-like strings
                if (/^\d+:\s*\([^)]+\)/.test(value)) return 'schedule';
                return 'string';
            }
            return typeof value;
        }

        // Update value input fields to be more flexible
        function updateValueFields(axis, type) {
            const container = document.getElementById(`${axis}ValueFields`);
            container.innerHTML = '';
            
            // Always create a text input, with a guidance note
            const div = document.createElement('div');
            div.className = 'input-group';
            div.innerHTML = `
                <input type="text" placeholder="Value or Range" class="${axis}-value">
                <button type="button" onclick="removeValue(this)">Remove</button>
                <div class="param-info">
                    <strong>Type:</strong> ${type}
                    <br>Supported formats: single value, ranges like "1-5", "1-5 (+2)", "1-10 [5]"
                    <br>Current value: ${JSON.stringify(getNestedProperty(baseSettings, document.getElementById(`${axis}Param`).value))}
                </div>
            `;
            
            container.appendChild(div);
        }

        // Update parameter info to be more informative
        function updateParamInfo(axis) {
            const param = document.getElementById(`${axis}Param`).value;
            const infoDiv = document.getElementById(`${axis}ParamInfo`);
            
            if (!param || !baseSettings) {
                infoDiv.innerHTML = '';
                return;
            }
            
            const value = getNestedProperty(baseSettings, param);
            const type = getParameterType(value);
            
            // Show parameter info with current value
            infoDiv.innerHTML = `
                <strong>Type:</strong> ${type}
                <br><strong>Current value:</strong> ${JSON.stringify(value)}
            `;
            
            // Update input fields
            updateValueFields(axis, type);
        }

        // Rest of the script remains the same as in the previous version...
        // (keep all other functions from the previous global-animation script)
    </script>
</body>
</html>
